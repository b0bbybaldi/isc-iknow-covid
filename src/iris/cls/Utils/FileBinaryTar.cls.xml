<?xml version="1.0" encoding="UTF-8"?>
<Export generator="IRIS" version="26">
<Class name="Utils.FileBinaryTar">
<Description>
Gratefully borrowed from https://github.com/daimor/isc-tar (MIT License)</Description>
<Super>%RegisteredObject,%ArrayOfDataTypes</Super>
<TimeCreated>65468,78057.314828</TimeCreated>

<Parameter name="BLOCKSIZE">
<Type>%Integer</Type>
<Default>512</Default>
</Parameter>

<Property name="name">
<Description>
name of file</Description>
<Type>%String</Type>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="100"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="mode">
<Description>
file mode</Description>
<Type>%String</Type>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="8"/>
</Property>

<Property name="uid">
<Description>
owner user ID</Description>
<Type>%String</Type>
<InitialExpression>..Dec2Oct(0, 6)</InitialExpression>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="8"/>
</Property>

<Property name="gid">
<Description>
owner group ID</Description>
<Type>%String</Type>
<InitialExpression>..Dec2Oct(0, 6)</InitialExpression>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="8"/>
</Property>

<Property name="size">
<Description>
length of file in bytes</Description>
<Type>%String</Type>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="12"/>
</Property>

<Property name="mtime">
<Description>
modify time of file</Description>
<Type>%String</Type>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="12"/>
</Property>

<Property name="chksum">
<Description>
checksum for header</Description>
<Type>%String</Type>
<InitialExpression>$JUSTIFY("", 8)</InitialExpression>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="8"/>
</Property>

<Property name="typeflag">
<Description>
type of file</Description>
<Type>%String</Type>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="DISPLAYLIST" value=",REGULAR,LINK,RESERVED,CHARACTER SPECIAL,BLOCK SPECIAL,DIRECTORY,FIFO SPECIAL,RESERVED"/>
<Parameter name="MAXLEN" value="1"/>
<Parameter name="VALUELIST" value=",0,1,2,3,4,5,6,7,x,g,L,K"/>
</Property>

<Property name="linkname">
<Description>
name of linked file</Description>
<Type>%String</Type>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="100"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="magic">
<Description>
USTAR indicator</Description>
<Type>%String</Type>
<InitialExpression>"ustar"</InitialExpression>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="6"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="version">
<Description>
USTAR version</Description>
<Type>%String</Type>
<InitialExpression>"00"</InitialExpression>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="2"/>
</Property>

<Property name="uname">
<Description>
owner user name</Description>
<Type>%String</Type>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="32"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="gname">
<Description>
owner group name</Description>
<Type>%String</Type>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="32"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="devmajor">
<Description>
device major number</Description>
<Type>%String</Type>
<InitialExpression>..Dec2Oct(0, 6)</InitialExpression>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="8"/>
</Property>

<Property name="devminor">
<Description>
device minor number</Description>
<Type>%String</Type>
<InitialExpression>..Dec2Oct(0, 6)</InitialExpression>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="8"/>
</Property>

<Property name="prefix">
<Description>
prefix for file name</Description>
<Type>%String</Type>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="155"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="fileData">
<Description>
file data</Description>
<Type>%Stream.Object</Type>
</Property>

<Method name="nameGet">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  Return i%prefix_i%name
]]></Implementation>
</Method>

<Method name="sizeGet">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[  Return $$oct2dec^%Wmdc(i%size)
]]></Implementation>
</Method>

<Method name="sizeSet">
<FormalSpec>pSize:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set i%size = ..Dec2Oct(pSize, 11)
  if ($length(i%size)>11) {
    return $$$ERROR(5001, "Size too big")
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="modeSet">
<FormalSpec>pMode:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if $$$isWINDOWS {
    set mode = 0
    set mask = 0
  } else {
    set mode = pMode
    set mask = 4095
  }
  set i%mode = ..Dec2Oct(mode, 6, mask)
  return $$$OK
]]></Implementation>
</Method>

<Method name="mtimeSet">
<FormalSpec>pTime:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set mtime =..Dec2Oct(pTime, 11)
  set i%mtime = mtime
  return $$$OK
]]></Implementation>
</Method>

<Method name="chksumSet">
<FormalSpec>pVal:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set tVal =..Dec2Oct(pVal, 6)
  set i%chksum = tVal
  return $$$OK
]]></Implementation>
</Method>

<Method name="Dec2Oct">
<ClassMethod>1</ClassMethod>
<FormalSpec>pVal:%Integer,pLen:%Integer,pMask:%Integer=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set val = pVal
  if (pMask>0) {
    set val = $ZBOOLEAN(val, pMask, 1)
  }
  set val = $$dec2oct^%Wmdc(val)
  set val = $JUSTIFY(val, pLen)
  set val = $TRANSLATE(val, " ", 0)
  set val = val _ $c(32)
  return val
]]></Implementation>
</Method>

<Method name="FindPath">
<FormalSpec>pPath:%String="",*found:FileBinaryTar</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set found = $$$NULLOREF
  set pPath = $tr(pPath, "\", "/")
  set tmp = ..GetAt($p(pPath, "/"))
  if '$isobject(tmp) {
    return $$$ERROR($$$GeneralError, "Path '"_pPath_"' not found")
  }
  if $l(pPath, "/")>1 {
    return tmp.FindPath($p(pPath, "/", 2, *), .found)
  }
  set found = tmp
  Return $$$OK
]]></Implementation>
</Method>

<Method name="ExtractFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>aFileName:%String="",Gzip:%Boolean=1,pDest:%String=""</FormalSpec>
<ReturnType>FileBinaryTar</ReturnType>
<Implementation><![CDATA[
  if aFileName = "" {
    Return $$$ERROR($$$GeneralError, "Filename not specified")
  }
  if Gzip {
    set fileStream=##class(%Stream.FileBinaryGzip).%New()
  } else {
    set fileStream=##class(%Stream.FileBinary).%New()
  }
  set fileStream.Filename=aFileName
  Return ..ExtractStream(fileStream, pDest)
]]></Implementation>
</Method>

<Method name="ExtractTo">
<FormalSpec>pDest:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if ..name'="" {
    if ..typeflag=5 {
      set fullPath = ##class(%File).NormalizeDirectory(..name, pDest)
      set sc = ##class(%File).CreateDirectoryChain(fullPath)
      if $$$ISERR(sc) {
        return sc
      }
    } else {
      set fullPath = ##class(%File).NormalizeFilename(..name, pDest)
      set fs = ##class(%Stream.FileBinary).%New()
      set fs.Filename = fullPath
      do fs.CopyFromAndSave(..fileData)
      do fs.%Close()
    }
  }

  set key = ""
  while ..GetNext(.key) {
    do ..GetAt(key).ExtractTo(pDest)
  }
  Return $$$OK
]]></Implementation>
</Method>

<Method name="ExtractStream">
<ClassMethod>1</ClassMethod>
<FormalSpec>aFileStream:%Stream.Object,pDest:%String=""</FormalSpec>
<ReturnType>FileBinaryTar</ReturnType>
<Implementation><![CDATA[
  #dim tFile As FileBinaryTar
  set blockSize = ..#BLOCKSIZE
  set result=..%New()
  while 'aFileStream.AtEnd {
    set tFile=..%New()
    set longLink4Name=""
    set longLink4Link=""
    do {
      set repeat=0
      set tHeader=aFileStream.Read(blockSize)
      do tFile.ParseHeader(tHeader)
      if tFile.name="./" {
        set repeat=1
        continue
      }
      If ($EXTRACT(tFile.name, 1, 2) = "./") {
        Set tFile.name = $EXTRACT(tFile.name, 3, *)
      }
      quit:tFile.name=""
      set $EXTRACT(tHeader, 149, 156) = $JUSTIFY("", 8)
      set chksumExpected = $zcrc(tHeader, 0)
      set chksum = $$oct2dec^%Wmdc(+tFile.chksum)
      if (chksumExpected'=chksum) {
        throw ##class(%Exception.General).%New("Checksum mismatch: "_chksumExpected_":"_chksum)
      }
      set fileSize=tFile.size
      set typeFlag=tFile.typeflag
      if (typeFlag="L") || (typeFlag="K") {
        set readBlocks=fileSize \ blockSize
        set:fileSize#blockSize>0 readBlocks=readBlocks + 1
        set longLink=aFileStream.Read(readBlocks * blockSize)
        set longLink=$zstrip(longLink,"<>",$char(0,32))
        set:(typeFlag="L") longLink4Name=longLink
        set:(typeFlag="K") longLink4Link=longLink
        set repeat=1
        continue
      }
      set repeat=0
      set:longLink4Name'="" tFile.name=longLink4Name
      set:longLink4Link'="" tFile.linkname=longLink4Link
    } while repeat
    set fileName=tFile.name
    quit:fileName=""
    if tFile.typeflag'="g" {
      do ..AddToArray(tFile, result)
    }
    continue:fileSize=0
    set readBlocks=fileSize \ blockSize
    set:fileSize#blockSize>0 readBlocks=readBlocks + 1
    if (pDest="") {
	  set tFile.fileData=##class(%Stream.FileBinary).%New()
   	  for tPos=1:1:readBlocks {
   	    set tData=aFileStream.Read(blockSize)
        set:tPos=readBlocks tData=$extract(tData, 1, fileSize#blockSize)
        do tFile.fileData.Write(tData)
   	  }
    } else {
      if tFile.typeflag=5 {
        set fullPath = ##class(%File).NormalizeDirectory(tFile.name, pDest)
        do ##class(%File).CreateDirectoryChain(fullPath)
      } else {
	    set fullPath = ##class(%File).NormalizeFilename(tFile.name, pDest)
        set fs = ##class(%Stream.FileBinary).%New()
        set fs.Filename = fullPath
   	    for tPos=1:1:readBlocks {
   	      set tData=aFileStream.Read(blockSize)
          set:tPos=readBlocks tData=$extract(tData, 1, fileSize#blockSize)
          do fs.Write(tData)
   	    }
        do fs.%Save()
      }
    }
    set:pDest="" result = tFile.fileData.%Save()
  }
  Return result
]]></Implementation>
</Method>

<Method name="AddToArray">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFile:FileBinaryTar,pArray:FileBinaryTar</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
  if ('$isobject(pFile)) || ('$isobject(pArray)) {
    return
  }
  
  set tFileName= $zstrip(pFile.name,"<>", "/")
  set tItem=pArray
  for i=1:1:$length(tFileName, "/")-1 {
    set tPathItem=$piece(tFileName, "/", i)
    if 'tItem.IsDefined(tPathItem) {
      do tItem.SetAt(..%New(), tPathItem)
    }
    set tItem=tItem.GetAt(tPathItem)
  }
  do tItem.SetAt(pFile, $piece(tFileName, "/", $length(tFileName, "/")))
]]></Implementation>
</Method>

<Method name="ParseHeader">
<Internal>1</Internal>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>aHeaderData:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set tProps=%class.Properties
  Set tPropKey = ""
  For {
    Set tProp = %class.Properties.GetNext(.tPropKey)
    Quit:(tPropKey = "")
    CONTINUE:"Header"'=tProp.Parameters.GetAt("CAPTION")
    set tProps(tProp.SequenceNumber)=tProp
  }	
  Set tPropKey = "", tPos = 0
  For {
    Set tPropKey = $Order(tProps(tPropKey),1,tProp)
    Quit:tPropKey=""
    Set tLen = tProp.Parameters.GetAt("MAXLEN")
    Do %code.WriteLine($char(9)_"Set i%"_tProp.Name_" = $zstrip($extract(aHeaderData, "_$increment(tPos)_", "_$increment(tPos, tLen - 1)_"), ""<>"", $c(0,32))")
    Do:tProp.Name="typeflag" %code.WriteLine($char(9)_"Set:i%"_tProp.Name_"=$c(0) i%"_tProp.Name_" = 0")
  }
  Return $$$OK
]]></Implementation>
</Method>

<Method name="Compact">
<ClassMethod>1</ClassMethod>
<FormalSpec>Path:%String="",gzip:%Boolean=1,pFileName:%String="",relativeTo:%String=""</FormalSpec>
<ReturnType>%Stream.FileBinary</ReturnType>
<Implementation><![CDATA[
  if (gzip) {
    set archive = ##class(%Stream.FileBinaryGzip).%New()
  } ELSE {
    set archive = ##class(%Stream.FileBinary).%New()		
  }
  if (pFileName'="") {
    Set tSC = archive.LinkToFile(pFileName)
    $$$ThrowOnError(tSC)
  }
  
  if relativeTo="" {
    set relativeTo = ##class(%File).ParentDirectoryName(Path)
  }
  set relativeTo = ##class(%File).NormalizeDirectory(relativeTo)

  Do ..ConstructTar(Path, relativeTo, archive)
  Set tSC = archive.%Save()
  $$$ThrowOnError(tSC)
  Do archive.%Close()
  
  return archive
]]></Implementation>
</Method>

<Method name="ConstructTar">
<ClassMethod>1</ClassMethod>
<FormalSpec>Path:%String,RelativeTo:%String,archive:%Stream.GlobalBinary</FormalSpec>
<Implementation><![CDATA[
  QUIT:Path=archive.Filename // skip archive itself
  set blockSize = ..#BLOCKSIZE
  if ##class(%File).DirectoryExists(Path) {
    set Path = ##class(%File).NormalizeDirectory(Path)
    set flag = 5 // Directory
    set size = 0
  } else {
    set Path = ##class(%File).NormalizeFilename(Path)
    set flag = 0 // Ordinary File
    set size = ##class(%File).GetFileSize(Path)
  }
  set name = $PIECE(Path, RelativeTo, 2, *)

  set mtime = ##class(%File).GetFileDateModified(Path, 1)
  set mtime = $ZDATETIME(mtime, -2)

  set mode = ##class(%File).Attributes(Path)

  set header = ""
  if name'="" {
    set obj = ..%New()
    set obj.name = name
    set obj.size = size
    set obj.mode = mode
    set obj.mtime = mtime
    set obj.typeflag = flag	
  
    set obj.uid = ""
    set obj.gid = ""
    set obj.uname = ""
    set obj.gname = ""
    
    set header = obj.ConstructHeader()
    set obj.chksum = $ZCRC(header, 0)
    set header = obj.ConstructHeader()
  }

  if (size > 0) {
    do archive.Write(header)
    set fs = ##class(%Stream.FileBinary).%New()
    set fs.Filename = Path
    do archive.CopyFrom(fs)
    if (size # blockSize) > 0 {
      set paddingSize = blockSize - (size # blockSize)
      set padding = $TRANSLATE($JUSTIFY("", paddingSize), " ", $CHAR(0))
      do archive.Write(padding)
    }
  } else {
    do archive.Write(header)
    set rs = ##class(%File).FileSetFunc(Path, , "Type", 1)
    while rs.%Next() {
      do ..ConstructTar(rs.Name, RelativeTo, archive)
    }
  }
]]></Implementation>
</Method>

<Method name="ConstructHeader">
<Internal>1</Internal>
<CodeMode>objectgenerator</CodeMode>
<ReturnType>%Binary</ReturnType>
<Implementation><![CDATA[
  set blockSize = ..#BLOCKSIZE
  set tProps=%class.Properties
  Set tPropKey = ""
  For {
    Set tProp = %class.Properties.GetNext(.tPropKey)
    Quit:(tPropKey = "")
    CONTINUE:"Header"'=tProp.Parameters.GetAt("CAPTION")
    set tProps(tProp.SequenceNumber)=tProp
  }	
  Do %code.WriteLine($char(9)_"Set tHeader = $TRANSLATE($JUSTIFY("""", "_blockSize_"), "" "", $CHAR(0))")
  Set tPropKey = "", tPos = 1
  For {
    Set tPropKey = $Order(tProps(tPropKey),1,tProp)
    Quit:tPropKey=""
    Set tLen = tProp.Parameters.GetAt("MAXLEN")
    Do %code.WriteLine($char(9)_"Set tVal = i%"_tProp.Name)
    If (tProp.Parameters.GetAt("TRUNCATE")) {
      Do %code.WriteLine($char(9)_"Set tVal = $extract(tVal, 1, "_(tLen-1)_")")
      #; Do %code.WriteLine($char(9)_"Set tVal = tVal _ $justify("""", "_(tLen)_" - $length(tVal))")
      #; Do %code.WriteLine($char(9)_"Set tVal = $translate(tVal, $char(32), $char(0))")
      Do %code.WriteLine($char(9)_"Set tPadding = $justify("""", "_(tLen)_" - $length(tVal))")
      Do %code.WriteLine($char(9)_"Set tPadding = $translate(tPadding, $char(32), $char(0))")
      Do %code.WriteLine($char(9)_"Set tVal = tVal _ tPadding")
    } else {
      Do %code.WriteLine($char(9)_"Set tVal = tVal _ $translate($justify("""", "_(tLen)_" - $length(tVal)), $char(32), $char(0))")
    }
    Do %code.WriteLine($char(9)_"Set tVal = $extract(tVal, 1, "_(tLen)_")")
    Do %code.WriteLine($char(9)_"Set $extract(tHeader, "_tPos_", "_(tPos+tLen-1)_") = tVal")
    Set tPos = tPos + tLen
  }
  Do %code.WriteLine($char(9)_"Return tHeader")
  Return $$$OK
]]></Implementation>
</Method>
</Class>
</Export>
